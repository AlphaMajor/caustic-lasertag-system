/*
 * devices-connectors.hpp
 *
 *  Created on: 08 дек. 2014 г.
 *      Author: alexey
 */

#ifndef LAZERTAG_DEVICE_INCLUDE_DEVICES_CONNECTORS_HPP_
#define LAZERTAG_DEVICE_INCLUDE_DEVICES_CONNECTORS_HPP_

using IncomingConnectorCallback = void (*)(void* object, unsigned int size, void *data, const uint8_t* sourceAddress);

#include <stdint.h>
#include <string.h>

const int MaxMessageSize = 20;
template <int MaxMessageSize>
class AnyConnectorBase
{
public:
    AnyConnectorBase() :
		m_incomingCallback(nullptr),
		m_incomingCallbackObject(nullptr),
		m_inDataSize(0),
		m_outDataSize(0),
		m_inputReady(false)
	{}

    virtual ~AnyConnectorBase() {}

    void setIncomingCallback(IncomingConnectorCallback callback, void* object) {
        m_incomingCallback = callback;
        m_incomingCallbackObject = object;
    }

    virtual void interrogate() {
    	if (m_inputReady && m_incomingCallback)
    		m_incomingCallback(m_incomingCallbackObject, m_inDataSize, m_bufferIn, nullptr);
    	m_inputReady = false;
    }

    virtual void sendData(const uint8_t* data, unsigned int size) {
    	packMessage(data, size);
    	physicalSend();
    }

protected:
    virtual void physicalSend() = 0;
    //virtual void physicalReceive() = 0;

    virtual void packMessage(const uint8_t* data, unsigned int size) {
		// Putting data
		memcpy(m_bufferOut, data, size*sizeof(uint8_t));
		m_outDataSize = size;
	}

    IncomingConnectorCallback m_incomingCallback;
    void *m_incomingCallbackObject;

    uint8_t m_bufferIn[MaxMessageSize];
    // Data prepared to be physically sent
    uint8_t m_bufferOut[MaxMessageSize];
    unsigned int m_inDataSize;
    unsigned int m_outDataSize;


    bool m_inputReady;
};

template<int AddressLen, int MaxMessageSize>
class AnyAddressableConnector : public AnyConnectorBase<MaxMessageSize>
{
public:
    AnyAddressableConnector() {}
    virtual ~AnyAddressableConnector() {}

    inline void setAddress(const uint8_t* address) {
        memcpy(m_address, address, AddressLen*sizeof(uint8_t));
    }

    inline const uint8_t* getAddress() { return m_address; }

    inline void setDestinationAddress(const uint8_t* address) {
        memcpy(m_destinationAddress, address, AddressLen*sizeof(const uint8_t));
    }

    inline const uint8_t* getDestinationAddress() { return m_destinationAddress; }

protected:
    using AnyConnectorBaseInstance = AnyConnectorBase<MaxMessageSize>;

    virtual void packMessage(const uint8_t* data, unsigned int size)
    {

    	// Putting destination address first
    	memcpy(AnyConnectorBaseInstance::m_bufferOut+AddressLen, m_destinationAddress, AddressLen*sizeof(uint8_t));
    	// Putting self address
    	memcpy(AnyConnectorBaseInstance::m_bufferOut, m_address, AddressLen*sizeof(uint8_t));
    	// Putting data
    	memcpy(AnyConnectorBaseInstance::m_bufferOut+2*AddressLen, data, size*sizeof(uint8_t));
    	AnyConnectorBaseInstance::m_outDataSize = 2*AddressLen + size;
    }

    virtual void unpackMassage(const uint8_t* data, unsigned int size)
    {
    	for (unsigned int i=0; i<AddressLen; i++)
    		if (data[i] != m_address[i])
    			return;

    	// Copying incoming address
    	memcpy(m_incomingAddress, data+AddressLen, AddressLen*sizeof(uint8_t));
    	// Copying data
    	memcpy(m_incomingAddress, data+AddressLen, AddressLen*sizeof(uint8_t));
    }

private:
    uint8_t m_address[AddressLen];
    uint8_t m_destinationAddress[AddressLen];
    uint8_t m_incomingAddress[AddressLen];
};


/*
class IRifleToMainSensorConnector : public IAnyConnector
{
public:

};

class IMainSensorToRifleConnector : public IAnyConnector
{
public:

};

class IAdditionalSensorToMainSensorConnector : public IAnyConnector
{
public:

};
*/




#endif /* LAZERTAG_DEVICE_INCLUDE_DEVICES_CONNECTORS_HPP_ */
