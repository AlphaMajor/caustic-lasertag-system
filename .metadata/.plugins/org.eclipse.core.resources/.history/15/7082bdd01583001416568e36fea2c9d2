/*
 * miles-tag-2.cpp
 *
 *  Created on: 05 нояб. 2014 г.
 *      Author: alexey
 */

#include "hal/miles-tag-2.hpp"
#include "exti-initialization-options.h"
#include "miles-tag-2-timings.h"
#include "utils.hpp"
#include "stm32f10x.h"
#include <stdio.h>

MilesTag2Receiver milesTag2Receiver;

/////////////////////
// Receiver



inline bool MilesTag2ReceiverBase::isCorrect(unsigned int value, unsigned int min, unsigned int max)
{
    return (value > min && value < max);
}

void MilesTag2Receiver::interruptionHandler()
{
    uint8_t status = GPIO_ReadInputDataBit(inputDescription[m_channel].GPIOx, inputDescription[m_channel].GPIO_Pin_x);
    unsigned int time = systemTimer.getTime();
    unsigned int dtime = time - m_lastTime;
    if (m_debug) printf("\ni %d %d %d ", (int) status, (int) dtime, (int)m_state);
    if (dtime < 15) {
        if (m_debug) printf ("short");
        m_falseImpulse = true;
        return;
    }

    if (m_falseImpulse) {
        if (m_debug) printf ("short back");
        m_falseImpulse = false;
        return;
    }
    m_lastTime = time;

    switch(m_state) {
    case RS_WAITING_HEADER:
        // We should have 1
        if (status == 0) {
            resetReceiver();
            return;
        }

        if (m_debug) printf ("hb ");
        // Header beginned
        m_state = RS_HEADER_BEGINNED;
        break;

    case RS_HEADER_BEGINNED: {
            // We should have 0
            if (status != 0)
            {
                resetReceiver();
                return;
            }

            if (m_debug) printf ("he ");
            if (isCorrect(dtime, HEADER_PERIOD_MIN, HEADER_PERIOD_MAX)) {
                if (m_debug) printf("ac \n");
                m_state = RS_SPACE;

            } else {
                resetReceiver();
                return;
            }
        } break;

    case RS_SPACE: {
            // We should have 1
            if (status == 0)
            {
                resetReceiver();
                return;
            }

            if (m_debug) printf ("sp ");
            if (isCorrect(dtime, BIT_WAIT_PERIOD_MIN, BIT_WAIT_PERIOD_MAX)) {
                if (m_debug) printf("ac \n");
                m_state = RS_BIT;
            } else {
                resetReceiver();
                return;
            }
        } break;

    case RS_BIT: {
            if (status != 0)
            {
                resetReceiver();
                return;
            }
            if (m_debug) printf ("b ");
            if (isCorrect(dtime, BIT_ONE_PERIOD_MIN, BIT_ONE_PERIOD_MAX)) {
                if (m_debug) printf("ac 1 \n");
                saveBit(true);
                m_state = RS_SPACE;
                if (getCurrentLength() == 14)
                    m_dataReady = true;
            } else if (isCorrect(dtime, BIT_ZERO_PERIOD_MIN, BIT_ZERO_PERIOD_MAX)) {
                if (m_debug) printf("ac 0 \n");
                saveBit(false);
                m_state = RS_SPACE;
                if (getCurrentLength() == 14)
                    m_dataReady = true;
            } else {
                resetReceiver();
                return;
            }
        } break;
    }
}

void MilesTag2ReceiverBase::interrogate()
{
    if (getCurrentLength() == 14 && getBit(0) == false) {
        parseAndCallShot();
        resetReceiver();
        // We have shot mesage
    }

    /// @todo determine message type
    /*
    if (!m_dataReady)
        return;

    m_dataReady = false;
    m_shortMessageCallback(m_shortMessageObject, m_data);

    resetReceiver();
    */
}

void MilesTag2ReceiverBase::parseAndCallShot()
{
    unsigned int playerId   = m_data[0] & ~(1 << 7);
    unsigned int teamId     = m_data[1] >> 6;
    unsigned int damageCode = (m_data[1] & 0b00111100) >> 2;
    m_shotCallback(m_shotObject, teamId, playerId, damageCode);
}

bool MilesTag2ReceiverBase::getBit(unsigned int n)
{
    return m_data[n / 8] & (1 << (7 - n%8));
}

void MilesTag2ReceiverBase::saveBit(bool value)
{
    if (m_pCurrentByte - m_data == MILESTAG2_MAX_MESSAGE_LENGTH)
        return;
    if (value)
        *m_pCurrentByte |= (1 << m_currentBit);
    else
        *m_pCurrentByte &= ~(1 << m_currentBit);

    if (m_currentBit == 0) {
        m_currentBit = 7;
        m_pCurrentByte++;
    } else
        m_currentBit--;
}

void MilesTag2Receiver::resetReceiver()
{
    m_pCurrentByte = m_data;
    m_currentBit = 7;
    m_state = RS_WAITING_HEADER;
    m_falseImpulse = false;
    m_dataReady = false;
}

int MilesTag2ReceiverBase::getCurrentLength()
{
    return (m_pCurrentByte - m_data)*8 + 7-m_currentBit;
}

void MilesTag2Receiver::enableDebug(bool debug)
{
    m_debug = debug;
}

uint8_t MilesTag2ReceiverBase::decodeDamage(uint8_t damage)
{
    switch(damage)
    {
    case 0: return 1;
    case 1: return 2;
    case 2: return 4;
    case 3: return 5;
    case 4: return 7;
    case 5: return 10;
    case 6: return 15;
    case 7: return 17;
    case 8: return 20;
    case 9: return 25;
    case 10: return 30;
    case 11: return 35;
    case 12: return 40;
    case 13: return 50;
    case 14: return 75;
    case 15: return 100;
    default: return 0;
    }
}

extern "C" void EXTI4_IRQHandler()
{
    if(EXTI_GetITStatus(EXTI_Line4) != RESET)
    {
        milesTag2Receiver.interruptionHandler();
        EXTI_ClearITPendingBit(EXTI_Line4);
    }
}

//////////////////
// MilesTag2ReceiverBase
MilesTag2ReceiverBase::MilesTag2ReceiverBase() :
	m_debug(false),
	m_shotCallback(nullptr),
	m_shotObject(nullptr),
	m_pCurrentByte(m_data),
	m_currentBit(7)
{
}

void MilesTag2ReceiverBase::setShortMessageCallback(MilesTag2ShotCallback callback, void* object)
{
    m_shotCallback = callback;
    m_shotObject = object;
}
